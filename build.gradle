description = 'Dasshy'

ext {

    javaLanguageLevel = '1.7'

    // dependencies versions
    sparkGroup      =   'org.apache.spark'
    sparkVersion    =   '2.0.0-SNAPSHOT'
    scalaVersion    =   '2.10'

    jettyGroup      =   'org.eclipse.jetty'
    jettyVersion    =   '8.1.19.v20160209'
    shiroVersion    =   '1.2.4'

    groovyVersion   =   '2.2.0'

    testNgVersion   =   '6.8.8'
    mockitoVersion  =   '1.9.5'
    festVersion     =   '2.0M10'

    archaiusVersion =   '0.7.4'

    thriftVersion   =   '0.9.3'

    jacksonGroup    =   'org.codehaus.jackson'
    jacksonVersion  =   '1.9.13'

    jerseyVersion   =   '2.22.2'

    libs = [

            spark_core:         "$sparkGroup:spark-core_$scalaVersion:$sparkVersion",
            spark_sql:          "$sparkGroup:spark-sql_$scalaVersion:$sparkVersion",
            spark_catalyst:     "$sparkGroup:spark-catalyst_$scalaVersion:$sparkVersion",
            spark_streaming:    "$sparkGroup:spark-streaming_$scalaVersion:$sparkVersion",
            spark_kafka:        "$sparkGroup:spark-streaming-kafka_$scalaVersion:$sparkVersion",

            jetty_server:       "$jettyGroup:jetty-server:$jettyVersion",
            jetty_servlet:      "$jettyGroup:jetty-servlet:$jettyVersion",
            jetty_http:         "$jettyGroup:jetty-http:$jettyVersion",
            jetty_security:     "$jettyGroup:jetty-security:$jettyVersion",

            shiro_core:         "org.apache.shiro:shiro-core:$shiroVersion",
            shiro_web:          "org.apache.shiro:shiro-web:$shiroVersion",

            jackson_core_asl:   "$jacksonGroup:jackson-core-asl:$jacksonVersion",
            jackson_mapper_asl: "$jacksonGroup:jackson-mapper-asl:$jacksonVersion",
            jackson_xc:         "$jacksonGroup:jackson-xc:$jacksonVersion",
            jackson_jaxrs:      "$jacksonGroup:jackson-jaxrs:$jacksonVersion",

            archaius:           "com.netflix.archaius:archaius-core:$archaiusVersion",

            thrift:             "org.apache.thrift:libthrift:$thriftVersion",

            groovy:             "org.codehaus.groovy:groovy-all:$groovyVersion",

            testNg:             "org.testng:testng:$testNgVersion",
            mockito:            "org.mockito:mockito-all:$mockitoVersion",
            fest:               "org.easytesting:fest-assert-core:$festVersion",

            jersey_test:        "org.glassfish.jersey.test-framework:jersey-test-framework-core:$jerseyVersion",
            jersey_grizzly:     "org.glassfish.jersey.test-framework.providers:jersey-test-framework-provider-grizzly2:$jerseyVersion",
            jersey_inmemory:    "org.glassfish.jersey.test-framework.providers:jersey-test-framework-provider-inmemory:$jerseyVersion"
    ]
}

// build scripts
buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.0.1"
        classpath "gradle.plugin.nl.javadude.gradle.plugins:license-gradle-plugin:0.13.1"
    }
}

// all projects configuration
allprojects { project ->
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    apply plugin: 'jacoco'

    defaultTasks 'build'

    repositories {
        mavenCentral()
        mavenLocal()
        maven {
            url "http://repository.apache.org/snapshots/"
        }
    }
}

// sub-projects configuration
subprojects { subProject ->

    apply plugin: 'java'
    apply plugin: "com.github.hierynomus.license"

    group = 'com.kromatik.dasshy'
    version = dasshyTargetVersion

    dependencies {

        testCompile(libs.testNg)
        testCompile(libs.mockito)
        testCompile(libs.fest)
    }

    javadoc {

        failOnError = true

    }

    license {
        header file("$rootDir/HEADER.txt")

        includes(["**/*.java", "**/*.properties", "**/*.yml", "**/*.gradle"])

        strictCheck true

        ext.year = Calendar.getInstance().get(Calendar.YEAR)
        ext.name = 'Dasshy'
        ext.org = 'Kromatik Solutions'
    }

    test {
        jacoco {
            destinationFile = file("$buildDir/jacoco/jacocoTest.exec")
        }
    }

    configurations {
        integrationTestCompile.extendsFrom testCompile
        integrationTestRuntime.extendsFrom testRuntime
    }

    sourceSets {
        integrationTest {
            java {
                compileClasspath += main.output + test.output
                runtimeClasspath += main.output + test.output
                srcDir file('src/integration-test/java')
            }
            resources.srcDir file('src/integration-test/resources')
        }
    }

    task integrationTest(type: Test) {
        testClassesDir = sourceSets.integrationTest.output.classesDir
        classpath = sourceSets.integrationTest.runtimeClasspath
        outputs.upToDateWhen { false }

        jacoco {
            destinationFile = file("$buildDir/jacoco/jacocoIntegTest.exec")
        }
    }

    tasks.withType(Test) {

        reports.html.destination = file("${reporting.baseDir}/${name}")

        useTestNG()
        include '**/*'

        minHeapSize = "128m"
        maxHeapSize = "512m"

        jvmArgs '-XX:MaxPermSize=256m'

        ext.useDefaultListeners = true
        ext.workingDirectory = 'build/'

        // listen to events in the test execution lifecycle
        beforeTest { descriptor ->
            logger.lifecycle("Running test: " + descriptor)
        }

        // listen to standard out and standard error of the test JVM(s)
        onOutput { descriptor, event ->
            logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
        }

        testLogging {
            showStandardStreams = true

            // log results to "build/test-results" directory
            exceptionFormat "full"
            events "started", "passed", "skipped", "failed", "standardOut", "standardError"
        }
    }

    check.dependsOn integrationTest
    integrationTest.mustRunAfter test

    targetCompatibility = javaLanguageLevel
    sourceCompatibility = javaLanguageLevel
}

// custom tasks
task docs(type: Javadoc) {

    options.encoding = 'utf-8'
    options.docEncoding = 'utf-8'
    options.charSet = 'utf-8'

    source subprojects.collect {project -> project.sourceSets.main.allJava }
    classpath = files(subprojects.collect {project -> [project.sourceSets.main.compileClasspath, project.sourceSets.main.output] })
    destinationDir = new File(projectDir, 'docs')
}

task jacocoMerge(type: JacocoMerge) {

    description = 'Merge test code coverage results'
    destinationFile = file("$buildDir/jacoco/jacoco.exec")
    doFirst {delete destinationFile}

    // get all execution data from subprojects and merge them
    subprojects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
}

task mergedReport(type: JacocoReport) {
    executionData jacocoMerge.destinationFile
    dependsOn jacocoMerge
    subprojects.each {
        sourceSets it.sourceSets.main
    }
}

// sonarqube
apply plugin: 'org.sonarqube'
sonarqube {
    properties {
        property "sonar.jacoco.reportPath", "$buildDir/jacoco/jacoco.exec"
        property "sonar.java.coveragePlugin", "jacoco"
    }
}
project(":dasshy-model") {
    sonarqube {
        properties {
            property "sonar.exclusions", "src/main/java/com/kromatik/dasshy/thrift/model/**"
            property "sonar.sourceEncoding", "UTF-8"
        }
    }
}
project.tasks["sonarqube"].dependsOn jacocoMerge